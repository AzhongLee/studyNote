《设计模式》	
http://www.cnblogs.com/beijiguangyong/archive/2010/11/15/2302807.html
http://www.runoob.com/design-pattern/design-pattern-intro.html
>对接口编程而不是对实现编程。
>优先使用对象组合而不是继承
//创建型
1. Factory Method（工厂方法）
	用一个单独的类来做创造实例的过程。
2. Abstract Factory（抽象工厂）
	提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
3. Builder（建造者）
	创建复杂对象的算法，独立于组成部分和装配方式。构建和表示分离，同样构建创建不同表示。
4. Prototype（原型）
	复制对象。浅复制与深复制。
5. Singleton（单例）
	保障一个类只有一个实例，并提供全局访问点。

//结构型
6. Adapter Class/Object（适配器）
	将一个类的接口转换为客户希望的另一个接口。兼容类。
7. Bridge（桥接）
	将抽象部分与它的实现部分分离，独立变化。
8. Composite（组合）
	[分公司＝－部门]：将对象组合成树形结构，表示“部分－整体”的层次结构。
9. Decorator（装饰）
	［穿衣服］动态的给一个对象添加一些额外的职责。把每个要装饰的功能放在单独的类中，并在类中包装这个对象。
10. Facade（外观）
	［股票与基金］为子系统的一组接口提供一个一致的界面。新系统与Facade对象交互，Facade与遗留代码交互复杂工作。
11. Flyweight（享元）
	[]运用共享技术有效的支撑大量细粒度的对象。大量对象开销大，实现共享一个对象。
12. Proxy（代理）
	［］为其他对象提供一种代理以控制对它的访问。远程代理、虚代理、保护代理、智能指引

//行为型
13. Interpreter（解释器）
	［音符］给定一个语言，定义它的文法的一种表示，并定义一个解释器用来解释语言中的句子。
14. Template Method（模板方法）
	[试卷]定义操作算法的骨架，而将一些步骤延迟到子类中。子类可以不改变算法结构即可重定义算法的某些特定步骤。
15. Chain of Responsibility（责任链）
	［加薪请求］使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。
16. Command（命令）
	［烤肉串］将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。
17. Iterator（迭代器）
	[售票员]提供一种方法顺序访问一个聚合对象中各个元素, 而又不需暴露该对象的内部表示。
18. Mediator（中介者）
	［联合国］用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。
19. Memento（备忘录）
	［游戏状态保存］在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。
20. Observer（观察者）
	［老板回来了］定义对象间的一种一对多的依赖关系,当一个对象的状态发生改变时, 所有依赖于它的对象都得到通知并被自动更新。
21. State（状态）
	［下班时间］允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。
22. Strategy（策略）
	［商场促销］定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。
23. Visitor（访问者）
	［男人女人］定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod 使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。

//设计模式的六大原则
1、开闭原则（Open Close Principle）
开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。
2、里氏代换原则（Liskov Substitution Principle）
里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
3、依赖倒转原则（Dependence Inversion Principle）
这个原则是开闭原则的基础，具体内容：针对对接口编程，依赖于抽象而不依赖于具体。
4、接口隔离原则（Interface Segregation Principle）
这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。
5、迪米特法则，又称最少知道原则（Demeter Principle）
最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。
6、合成复用原则（Composite Reuse Principle）
合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。